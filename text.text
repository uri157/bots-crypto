¡Perfecto! Con la base lista, te propongo cerrar **qué falta en el bot** para persistir runs/órdenes/fills/equity en Postgres, **sin código** aún. Esto es un checklist de *qué* haremos, *dónde* engancha en tu bot y *cómo* lo validamos.

---

# Plan de integración Bot ↔ Postgres

## 0) Configuración (sin tocar lógica)

* **Nuevas env vars** en el bot:

  * `DB_URL` (conn string psycopg), `RUN_ENV` (`sim|paper|prod`), `BOT_ID` (`ema`), `INSTANCE_ID` (hostname/uuid), `VENUE` (`binance-sim` o `binance-futures`).
* **Dependencia**: cliente Postgres (psycopg).
* **Feature flag**: `DB_ENABLED=true|false` por si querés desactivar escritura.

> Dónde: `ema/config.py` (o config central) y README.

---

## 1) Vida de una “run” (arranque → fin)

### En `runner/ema.py` (o bootstrap del bot)

1. **Calcular/Registrar la strategy\_config**

   * `strategy_code`: p.ej. `ema_cross_v1`.
   * `params_json`: parámetros efectivos (fast, slow, alloc\_usdt, stop\_pct, allow\_shorts…).
   * `params_hash`: hash estable del JSON (idempotencia).
   * **Upsert** en `strategy_configs` y guardar `cfg_id`.

2. **Crear la run**

   * Generar `run_id` (uuid4).
   * Insert en `runs` con: `cfg_id`, `bot_id`, `instance_id`, `environment`, `venue`, `symbol`, `base_tf`.
   * Guardar `run_id` en memoria del proceso.

3. **Marcar fin limpio**

   * Al shutdown (SIGINT/SIGTERM): set `finished_at=now()` para la `run_id`.

> Dónde: `runner/ema.py` (ya tenés el `main` que construye `EmaExecutor`); ahí abrimos/gestionamos la conexión y hacemos “begin/end run”.

---

## 2) Flujo de órdenes y fills (núcleo)

### En `ema/executor.py`

Enganches exactos:

* **Orden de entrada/stop/exit** (BUY/SELL/STOP\_MARKET):

  * Tras recibir la **respuesta del exchange** (sim o real), escribir en **`orders`**:

    * Claves: `run_id`, `bot_id`, `instance_id`, `environment`, `venue`, `symbol`.
    * Identidad: `client_order_id` (ya lo generás), `venue_order_id` (si viene), `status`, `side`, `order_type`, `time_in_force`, `reduce_only`.
    * Valores: `price`, `stop_price`, `quantity`, `quote_qty` (si aplica), `leverage` (si aplica).
    * Tiempos: `created_ts_ms` (cliente), `exchange_ts_ms` (si viene).
  * **Idempotencia**: garantizada por `UNIQUE (venue, client_order_id)`.

* **Fills** (ejecuciones):

  * Si la respuesta trae `fills[]` → insertar **N** filas en **`fills`** con `order_uid`, `run_id`, `seq` (0..N-1), `ts_ms`, `price`, `qty`, `fee`, `is_maker`, `realized_pnl` (si lo calculás).
  * Si no trae `fills` pero trae `avgPrice` → 1 fill sintético (`seq=0`) con ese precio y `fee=0` o aprox.
  * **Idempotencia de fills**: `UNIQUE (order_uid, seq)`.

* **Cancelación de stops**:

  * Cuando cancelás el SL previo, **actualizar** `orders.status='CANCELED'` donde `venue_order_id` (o por `client_order_id`).

> Dónde: dentro de `_ensure_long/_ensure_short/_close_position` justo después de cada `place_order`, y al cancelar stops.

---

## 3) Equity curve (opcional pero recomendado)

* **Cuándo grabar**:

  * Al **cerrar cada vela** (en el callback que ya tenés) y/o cuando cambia la posición.
* **Qué grabar** en **`equity_curve`**:

  * `run_id`, `ts_ms` (cierre de la vela), `equity` (USDT).
* **De dónde sacar equity**:

  * En `sim`: lo podés pedir al gateway (tu simulator devuelve `equity_now`), o mantener un PnL tracker.
  * En `prod/paper`: mínimo podrías guardar “equity estimada” (= balance inicial + realized PnL – fees). Mejor más adelante: snapshot real de exchange.

> Dónde: en `runner/ema.py` (cuando ya sabés el `close` y antes/después de `on_candle_close`) o en el executor tras cada cambio de posición.

---

## 4) Mapeo columnas ↔ datos existentes

**runs**

* `run_id` (uuid4), `cfg_id`, `bot_id` (`ema`), `instance_id` (hostname/uuid), `environment` (`sim|paper|prod`), `venue` (`binance-sim`), `symbol` (`BTCUSDT`), `base_tf` (`1h`), timestamps.

**orders**

* `client_order_id`: ya lo formás `ema-<SYM>-<ms>` y `...-SL` para stops.
* `venue_order_id`: del simulator/venue.
* `side`, `order_type` (`MARKET`, `STOP_MARKET`), `status` (`FILLED`, `NEW`, `CANCELED`), `reduce_only` (para SL/exit).
* `price`, `stop_price`, `quantity`, `quote_qty` (si aplica), `created_ts_ms` (cliente), `exchange_ts_ms` (venue).
* Claves contextuales: `run_id`, `bot_id`, `instance_id`, `environment`, `venue`, `symbol`.

**fills**

* `order_uid` (PK de orders), `run_id`, `seq`, `ts_ms`, `price`, `qty`, `fee`, `fee_asset`, `is_maker`, `realized_pnl`, `side`.

**equity\_curve**

* `run_id`, `ts_ms`, `equity`.

---

## 5) Tolerancia a fallos (DB down) — sin bloquear el trading

* **No bloquear órdenes** si la DB falla.
* **Cola local de eventos** (disk/Redis) para *“at-least-once”*:

  * Encolar `{type: "order"/"fill"/"equity", payload}` si falla la escritura.
  * Proceso retry “best effort” (backoff) para drenar la cola.
* **Idempotencia** evita duplicados:

  * Orders: `UNIQUE (venue, client_order_id)`.
  * Fills: `UNIQUE (order_uid, seq)`.
  * Equity: `PRIMARY KEY (run_id, ts_ms)`.

> Dónde: `storage/` ya existe; ahí podemos colar un `writer` + `backlog` simple. (Luego, si querés, lo movemos a un microservicio).

---

## 6) Métricas/observabilidad (nice to have)

* Contadores de “db\_write\_ok / db\_write\_err” por tipo (order/fill/equity).
* Latencia de inserts (histogram).
* `bot_up{bot="ema"}` ya lo tenés.

---

## 7) Seguridad & conexiones

* **Pool de conexiones** (1 proceso ↔ N workers async → pool pequeño, p.ej. 5–10).
* `sslmode=require` cuando muevas la DB fuera del host.
* No loguear `DB_URL` completo (ocultar password).

---

## 8) Prueba de punta a punta (sin SQL manual)

1. Arrancar simulator + bot (con `DB_URL` apuntando a tu Postgres).
2. Trigger de replay y esperar un par de velas/órdenes.
3. Consultas de verificación (DB):

   * `SELECT COUNT(*) FROM runs WHERE environment='sim' AND bot_id='ema';`
   * `SELECT * FROM v_run_summary ORDER BY started_at DESC LIMIT 5;`
   * `SELECT * FROM orders WHERE run_id='...' ORDER BY created_at;`
   * `SELECT * FROM fills WHERE run_id='...' ORDER BY ts_ms;`
   * `SELECT * FROM equity_curve WHERE run_id='...' ORDER BY ts_ms DESC LIMIT 5;`
4. `smoke_teardown.sql` **no** lo uses aquí (borra smoke). Para pruebas reales usá tus propias consultas o una `teardown` por `run_id`.

---

## 9) Decisiones abiertas (para acordar antes de codear)

* **Dónde calcular `equity`** ahora mismo (sim vs prod). Propuesta:

  * En `sim`: llamar al gateway status y grabar.
  * En `prod/paper`: por ahora *sólo* orders/fills; equity lo añadimos tras definir balance source.
* **Granularidad de equity**: por vela (recomendado) o cada fill (más granular).
* **Backlog store**: archivo en `storage/` (rápido) o Redis (si ya lo tenés).
* **Forma de hash de params**: `md5(json_dumps(params, sort_keys=True))`.
* **`strategy_code`**: congelar nombre (`ema_cross_v1`) para comparabilidad.

---

## 10) “Dónde tocar” (mapa mínimo de cambios)

* `ema/config.py` → nuevas env vars (DB\_URL, RUN\_ENV, etc.).
* `runner/ema.py` → conexión DB, upsert `strategy_configs`, insert `runs`, mark `finished_at`, equity por vela.
* `ema/executor.py` → persistir `orders`/`fills`, actualizar cancelaciones.
* `storage/` → (opcional) cola/backlog + writer centralizado.
* README del bot → sección “Persistencia en Postgres”.

---

## 11) Criterios de aceptación

* Ejecutar una run **completa** con el simulator:

  * Existe **1 fila** en `runs` (con `finished_at` si apagás el bot).
  * `orders` y `fills` reflejan todas las operaciones del log.
  * `equity_curve` tiene ≥ 2 puntos.
  * `v_run_summary` devuelve métricas coherentes (fills, fees, realized/net PnL, ret\_pct).
* Si la DB se apaga durante la run:

  * El bot **no se cae** y **coloca órdenes igual**.
  * Al volver la DB, el backlog se drena (no hay duplicados).

---

Si te cierra este plan, paso a **codificar por etapas**: (1) bootstrap de run/config, (2) persistencia de orders/fills, (3) equity por vela, (4) backlog & retries.
